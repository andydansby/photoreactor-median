// plugin.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "IPlugin.h"

#include <math.h>
#include <cmath>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>//to use cout

#include <algorithm>    // std::sort
#include <ctime>

using namespace std;


////////////////////////////////////////////////////////////////////////
// A concrete plugin implementation
////////////////////////////////////////////////////////////////////////

// Photo-Reactor Plugin class

//****************************************************************************
//This code has been generated by the Mediachance photo reactor Code generator.


#define AddParameter(N,S,V,M1,M2,T,D) {strcpy (pParameters[N].m_sLabel,S);pParameters[N].m_dValue = V;pParameters[N].m_dMin = M1;pParameters[N].m_dMax = M2;pParameters[N].m_nType = T;pParameters[N].m_dSpecialValue = D;}

#define GetValue(N) (pParameters[N].m_dValue)
#define GetValueY(N) (pParameters[N].m_dSpecialValue)

#define SetValue(N,V) {pParameters[N].m_dValue = V;}

#define GetBOOLValue(N) ((BOOL)(pParameters[N].m_dValue==pParameters[N].m_dMax))

// if it is not defined, then here it is
//#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))

#define PARAM_RADIUS	0
#define NUMBER_OF_USER_PARAMS 1

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
#define ELEM_SWAP(a,b) { float t=(a);(a)=(b);(b)=t; }


class Plugin1 : public IPlugin	
{
public:

		//Plugin Icon:
	//you can add your own icon by creating 160x100 png file, naming it the same as plugin dll and then placing it in the plugins folder
	//otherwise a generic icon will be use


	//this is the title of the box in workspace. it should be short
	const char* GetTitle () const
	{
		return "median";
	}
	
	// this will appear in the help pane, you can put your credits and short info
	const char* GetDescription () const
	{
		return "median";
	}

	// BASIC PARAMETERS
	// number of inputs 0,1 or 2
	int GetInputNumber ()
	{
		return 1;
	}

	// number of outputs 0 or 1
	int GetOutputNumber ()
	{
		return 1;
	}

	int GetBoxColor ()
	{
		return RGB(44,78,119);
	}

	int GetTextColor ()
	{
		return RGB(165,236,255);
	}

	// width of the box in the workspace
	// valid are between 50 and 100
	int GetBoxWidth ()
	{
		return 80;
	}

	// set the flags
	// see the interface builder
	// ex: nFlag = FLAG_FAST_PROCESS | FLAG_HELPER;

	//FLAG_NONE same as zero	Default, no other flags set
	//FLAG_UPDATE_IMMEDIATELY	It is very fast process that can update immediately. When user turns the sliders on UI the left display will update
	//							Use Update Immediately only for fast and single loop processes, for example Desaturate, Levels.
	//FLAG_HELPER				It is an helper object. Helper objects will remain visible in Devices and they can react to mouse messages. Example: Knob, Monitor, Bridge Pin
	//FLAG_BINDING				Binding object, attach to other objects and can change its binding value. It never goes to Process_Data functions.  Example: Knob, Switch, Slider
	//FLAG_DUMMY				It is only for interface but never process any data. Never goes to Process_Data functions. Example: Text note
	//FLAG_SKIPFINAL			Process data only during designing, doesn't process during final export. Example: Monitor, Vectorscope 
	//FLAG_LONGPROCESS			Process that takes > 1s to finish. Long Process will display the Progress dialog and will prevent user from changing values during the process.
	//FLAG_NEEDSIZEDATA		    Process need to know size of original image, the zoom and what part of image is visible in the preview. When set the plugin will receive SetSizeData
	//FLAG_NEEDMOUSE			Process will receive Mouse respond data from the workplace. This is only if your object is interactive, for example Knob, Slider

	int GetFlags ()
	{
		// it is fast process
		int nFlag = FLAG_UPDATE_IMMEDIATELY;
		
		return nFlag;
	}


	// User Interface Build
	// there is maximum 29 Parameters

	int GetUIParameters (UIParameters* pParameters)
	{

		// label, value, min, max, type_of_control, special_value
		// use the UI builder in the software to generate this


		AddParameter( PARAM_RADIUS ,"Radius", 3.0, 1.0, 10.0, TYPE_SLIDER, 0.0);//default min max

		return NUMBER_OF_USER_PARAMS;
	}


//#####################################################


//#####################################################	
	//works, but slower
	float quickSelectFloat(float *floatArray, int length, float kTHvalue)
	{
#	define SWAP(a, b) { tmp = floatArray[a]; floatArray[a] = floatArray[b]; floatArray[b] = tmp; }
		int i, st;
		float tmp;
 
		for (st = i = 0; i < length - 1; i++) 
		{
			if (floatArray[i] > floatArray[length-1]) continue;
			SWAP(i, st);
			st++;
		}
 
		SWAP(length-1, st);
# undef swap
		return kTHvalue == st	? floatArray[st]
		:st > kTHvalue	? quickSelectFloat(floatArray, st, kTHvalue)
			: quickSelectFloat(floatArray + st, length - st, kTHvalue - st);
	}
//#####################################################	
	void gnomeSortFloat(float *floatArray, int length)
	{
		int i=1, j=2;
		float temp;
# define swap(i, j) { temp = floatArray[i]; floatArray[i] = floatArray[j]; floatArray[j] = temp; } 
		while(i < length) 
		{
			if (floatArray[i - 1] > floatArray[i]) 
			{
				swap(i - 1, i);
				if (--i) continue;
			}
			i = j++;
		}
# undef swap
	}
//#####################################################	
	void selectionSortFloat (float *array, int length) 
	{
		int i,j,l;
		float temp;
		for (i = 0; i < length; i++) 
		{
			for (j = i, l = i; j < length; j++) 
			{
				if (array[j] < array[l]) 
				{
					l = j;
				}
			}
			temp = array[i];
			array[i] = array[l];
			array[l] = temp;
		}
	}
//#####################################################	
	void insertionSortFloat(float array[], int length)
	{
		int i, j;
		float key;
		for (i = 1; i < length; i++)
		{
			key = array[i];
			j = i-1;
 
			// Move elements of arr[0..i-1], that are
			// greater than key, to one position ahead
			//of their current position 
			while (j >= 0 && array[j] > key)
			{
				array[j+1] = array[j];
				j = j-1;
			}
			array[j+1] = key;
		}
	}
//#####################################################	
	void insertionSortFloat2(float array[],int length)
	{
		for(int n = 1;n < length;n++) 
		{
			float key = array[n];
			int k = n;
			while(k > 0)
			{
				if(array[k-1] > key) 
				{
					array[k] = array[k-1];
					k--;
				} else
					break;
			}
			array[k] = key;
		}
	}
//#####################################################
	void shellSortFloat (float *array, int length) 
	{
		int h, i, j;
		float t;
		for (h = length; h /= 2;) 
		{
			for (i = h; i < length; i++) 
			{
				t = array[i];
				for (j = i; j >= h && t < array[j - h]; j -= h) 
				{
					array[j] = array[j - h];
				}
				array[j] = t;
			}
		}
	}

/*
	float trashMin(float *array, int length)
	{
		//what we want to do in this routine is find the lowest in the array
		//we then make the lowest number, the same as the highest possible number and 
		//after iteratively going through the array 1/2 of the full length we will find the median

		unsigned int halflength = (length / 2) + 1;
		unsigned i, j, k;
		float highNumber = 256.0;
		float median = 0;

		for (i = 0; i < halflength; ++i)
		{
			float lowestInArray = array[0];
			bool firstOne = true;// is it the first time we see this number
			
			for (j = 0; j < length; ++j)
			{// find the lowest and highest number in the array
				float comparitor = array[j];
				lowestInArray = (lowestInArray < comparitor) ? lowestInArray : comparitor;
			}//end j

			// now that we know which is the smallest number, eliminate only 1 occurance of it
			
			for (k = 0; k < length; ++k)
			{
				float comparitor = array[k];				
				if (comparitor == lowestInArray && firstOne == true)
				{
					array[k] = highNumber;
					firstOne = false;
				}
			}//end k
			median = lowestInArray;
		}//end i
		return median;
	}
*/

	float trashMin(float array[], unsigned int length, float median)
	{
		//what we want to do in this routine is find the lowest in the array
		//we then make the lowest number, the same as the highest possible number and 
		//after iteratively going through the array 1/2 of the full length we will find the median

		unsigned int halflength = (length / 2) + 1;
		unsigned int i = 0;
		unsigned int j = 0;
		unsigned int k = 0;
		float highNumber = 256.0;
		float median = 0;

		for (i = 0; i < halflength; ++i)
		{
			float lowestInArray = array[0];
			bool firstTime = true;// is it the first time we see this number
			
			for (j = 0; j < length; ++j)
			{// find the lowest and highest number in the array
				float comparitor = array[j];
				lowestInArray = (lowestInArray < comparitor) ? lowestInArray : comparitor;
			}//end j

			// now that we know which is the smallest number, eliminate only 1st occurance of it			
			for (k = 0; k < length; ++k)
			{
				float comparitor = array[k];				
				if (comparitor == lowestInArray && firstTime == true)
				{
					array[k] = highNumber;
					firstTime = false;
				}
			}//end k
			median = lowestInArray;
		}//end i
		return median;
	}


	//Shell sort Brand new, not optimized
	void shellSort(float a[], int hi) 
	{
		int i, j, gap;
		float temp;
 
		for(gap = hi/2; gap > 0; gap /= 2) 
		{ //original Shell divisor
			for(i = gap; i < hi; i++) 
			{
				temp = a[i];
				j = i;
				while(j>= gap && a[j-gap] > temp) 
				{
					a[j] = a[j - gap];
					j = j - gap;
				}
				a[j] = temp;
			}
		}
	}

	void heapsort(float a[],int n) 
	{
		int i;
		float t;
		heapify(a,n);
		for (i=n-1;i>0;i--)
		{
			t = a[0];
			a[0] = a[i];
			a[i] = t;
			adjust(a,i);
		}
	}

	void heapify(float a[],int n) 
	{
		int k,i,j;
		float item;
		for (k=1;k<n;k++) 
		{
			item = a[k];
			i = k;
			j = (i-1)/2;
			while((i>0)&&(item>a[j])) 
			{
				a[i] = a[j];
				i = j;
				j = (i-1)/2;
			}
			a[i] = item;
		}
	}

	void adjust(float a[],int n) 
	{
		int i,j;
		float item;
		j = 0;
		item = a[j];
		i = 2*j+1;
		while(i<=n-1) 
		{
			if(i+1 <= n-1)
				if(a[i] <a[i+1])
					i++;
			if(item<a[i]) 
			{
				a[j] = a[i];
				j = i;
				i = 2*j+1;
			} 
			else
				break;
		}
		a[j] = item;
	}

	//#############################################################################################

void Partition(float* ipA, int iSize) {

    // Partitions of size 0 or 1 are already sorted
    if (iSize <= 1) {
        return;
    }

    // Select a pivot from the array randomly
    int iPivot = ipA[rand() % iSize];

    // Indices of the entries to be swapped
    int iLower = 0;
    int iUpper = iSize - 1;

    // Partition array into sections above and below the pivot
    while (iLower < iUpper) {

        while (ipA[iLower] < iPivot) {
            ++iLower;
        }

        while (ipA[iUpper] > iPivot) {
            --iUpper;
        }

        // Swap the entries at the lower and upper indices
        int iTemp       = ipA[iLower];
        ipA[iLower]     = ipA[iUpper];
        ipA[iUpper]     = iTemp;
    }

    // Recursively call partition on each partititon.
    Partition(ipA, iLower);
    Partition(&(ipA[iLower + 1]), iSize - iLower - 1);
}

void Quicksort(float* ipA, int iSize) {
    // Seed the random number generator
    srand((float)time(0));
    Partition(ipA, iSize);
}




	/*
		//char sBuffer6[400]; 
		//sprintf(sBuffer6,"redfront = %d\n redcenter = %d\n redback = %d\n\n radius = %d\n size = %d\n divisor = %d\n\n redsum = %d\n avgRed = %d\n\n y=%d\n x=%d"
		//                 ,redfront,       redcenter,       redback,         radius,       size,       divisor,         redsum,       avgRed,         y,     x);
		//MessageBox(NULL,sBuffer6,"RED", MB_OK);
		*/

	// Actual processing function for 1 input
	//***************************************************************************************************
	// Both buffers are the same size
	// don't change the IN buffer or things will go bad for other objects in random fashion
	// the pBGRA_out comes already with pre-copied data from pBGRA_in
	// Note: Don't assume the nWidth and nHeight will be every run the same or that it contains the whole image!!!! 
	// This function receives buffer of the actual preview (it can be just a crop of image when zoomed in) and during the final calculation of the full buffer
	// this is where the image processing happens
	virtual void Process_Data (BYTE* pBGRA_out,BYTE* pBGRA_in, int nWidth, int nHeight, UIParameters* pParameters)
	{
		//List of Parameters
		double dRadius = GetValue(PARAM_RADIUS);// used to grab radius from control
		int radius = (int)dRadius;//convert radius to an interger
		int size = (2 * radius) + 1;// we want an odd sized kernel

		float colorDepth = 255.0f;

		float* outputarray = new float[nWidth * nHeight * 4];// this is our output array
		float* inputarray = new float[nWidth * nHeight * 4];

		int widthMinus = nWidth - 1;
		int heightMinus = nHeight - 1;

		//place our image in a seperate array in the 0-1 range, where 0 is darkest and 1 is lightest
		for (int x = 0; x < nWidth; x++)
		{
			for (int y = 0; y < nHeight; y++)
			{
					int nIdx = x * 4 + y * 4 * nWidth;
					//float red = pBGRA_in[nIdx + CHANNEL_R] / colorDepth;
					//float green = pBGRA_in[nIdx + CHANNEL_G] / colorDepth;
					//float blue = pBGRA_in[nIdx + CHANNEL_B] / colorDepth;

					float red = pBGRA_in[nIdx + CHANNEL_R];
					float green = pBGRA_in[nIdx + CHANNEL_G];
					float blue = pBGRA_in[nIdx + CHANNEL_B];

					inputarray[nIdx + CHANNEL_R] = red;
					inputarray[nIdx + CHANNEL_G] = green;
					inputarray[nIdx + CHANNEL_B] = blue;
			}
		}

		for(int y = 0; y < nHeight; y++)
		{
			for(int x = 0; x < nWidth; x++)
			{
				int nIdx1 = x * 4 + y * 4 * nWidth;//center of kernel
				//(x + y * nWidth) * 4

				//small array for each kernel to grab each value for median sorting
				float* Rkernelarray = new float[size*size]; // kernel array
				float* Gkernelarray = new float[size*size]; // kernel array
				float* Bkernelarray = new float[size*size]; // kernel array
				int elementsinarray = 0;

				//This is our Kernel
				//accumulate colors
				for(int i = x - radius; i <= x + radius; i++)
				{
					for(int j = y - radius; j <= y + radius; j++)
					{
						if (i < 0 || i > widthMinus || j < 0 || j > heightMinus)  continue;
						int nIdx2 = i * 4 + j * 4 * nWidth;

						//this slides / moves along the kernel to collect the neighboring pixels
						float redKernelSlider   = inputarray[nIdx2 + CHANNEL_R];
						float greenKernelSlider = inputarray[nIdx2 + CHANNEL_G];
						float blueKernelSlider  = inputarray[nIdx2 + CHANNEL_B];
						//this slides / moves along the kernel to collect the neighboring pixels

						Rkernelarray[elementsinarray] = redKernelSlider;
						Gkernelarray[elementsinarray] = greenKernelSlider;
						Bkernelarray[elementsinarray] = blueKernelSlider;

						elementsinarray ++;
					}//end J
				}//end I

				float* redArray = new float[elementsinarray]; // kernel array
				float* greenArray = new float[elementsinarray]; // kernel array
				float* blueArray = new float[elementsinarray]; // kernel array

				//at the edges of the image, the kernel size does not match to the selected size
				//we present another array series.  If you are at the edges, the new array will be
				//smaller, away from the edges the kernel array is the same size.  This routine
				//just copies
				for(int i = 0; i < elementsinarray; i++)
				{
					redArray[i] = Rkernelarray[i];
					greenArray[i] = Gkernelarray[i];
					blueArray[i] = Bkernelarray[i];
				}
				
				// lets delete those arrays
				delete [] Rkernelarray;
				delete [] Gkernelarray;
				delete [] Bkernelarray;

				//points to the center value (median)
				int middleElement = elementsinarray / 2;

				float rmedian = 0;
				float gmedian = 0;
				float bmedian = 0;

				//median can be calculated easily if the array is sorted
				//Use this area to test out different sort methods
				// Shell Sort
				//shellSortFloat(redArray, elementsinarray);
				//shellSortFloat(greenArray, elementsinarray);
				//shellSortFloat(blueArray, elementsinarray);

				//rmedian = redArray[middleElement];
				//gmedian = greenArray[middleElement];
				//bmedian = blueArray[middleElement];

				//Shell Sort

				rmedian = trashMin(redArray, elementsinarray);
				gmedian = trashMin(greenArray, elementsinarray);
				bmedian = trashMin(blueArray, elementsinarray);

					//char sBuffer7[100];
					//sprintf(sBuffer7,"median = %f",rmedian);
					//MessageBox(NULL,sBuffer7,"MEDIAN", MB_OK);

				//float rmedian = heapMedian3(redArray);
				//float gmedian = heapMedian3(greenArray);
				//float bmedian = heapMedian3(blueArray);

				


				{//output
					outputarray[nIdx1 + CHANNEL_R] = rmedian;
					outputarray[nIdx1 + CHANNEL_G] = gmedian;
					outputarray[nIdx1 + CHANNEL_B] = bmedian;
				}//end output

				// lets delete those arrays
				delete [] redArray;
				delete [] greenArray;
				delete [] blueArray;
			}//end X
		}//end Y

		delete [] inputarray;


#pragma region	//test for proof that the image is blurred with median
		
		for (int x = 0; x < nWidth; x++)
		{
			for (int y = 0; y < nHeight; y++)
			{
				int nIdx = x * 4 + y * 4 * nWidth;
				
				//int nR = outputarray [nIdx + CHANNEL_R] * colorDepth;
				//int nG = outputarray [nIdx + CHANNEL_G] * colorDepth;
				//int nB = outputarray [nIdx + CHANNEL_B] * colorDepth;

				int nR = outputarray [nIdx + CHANNEL_R];
				int nG = outputarray [nIdx + CHANNEL_G];
				int nB = outputarray [nIdx + CHANNEL_B];

				pBGRA_out[nIdx + CHANNEL_R] = nR;
				pBGRA_out[nIdx + CHANNEL_G] = nG;
				pBGRA_out[nIdx + CHANNEL_B] = nB;				
			}
		}

#pragma endregion

	delete [] outputarray;
}//end routine



/*
char sBuffer7[400]; 
				sprintf(sBuffer7,"elementsinarray = %d",elementsinarray);
				MessageBox(NULL,sBuffer7,"Elements in Kernel", MB_OK);
*/
						/*
						char sBuffer6[400]; 
						sprintf(sBuffer6,"x = %d\n y = %d\n\n i = %d\n j = %d\n\n elementsinarray = %d\n\n redKernelSlider = %f"
							,x,       y, i,j, elementsinarray,      redKernelSlider);
						MessageBox(NULL,sBuffer6,"Fill Kernel", MB_OK);
						*/
						


	// actual processing function for 2 inputs
	//********************************************************************************
	// all buffers are the same size
	// don't change the IN buffers or things will go bad
	// the pBGRA_out comes already with copied data from pBGRA_in1
	virtual void Process_Data2 (BYTE* pBGRA_out, BYTE* pBGRA_in1, BYTE* pBGRA_in2, int nWidth, int nHeight, UIParameters* pParameters)
	{

	}


	//*****************Drawing functions for the BOX *********************************
	//how is the drawing handled
	//DRAW_AUTOMATICALLY	the main program will fully take care of this and draw a box, title, socket and thumbnail
	//DRAW_SIMPLE_A			will draw a box, title and sockets and call CustomDraw
	//DRAW_SIMPLE_B			will draw a box and sockets and call CustomDraw
	//DRAW_SOCKETSONLY      will call CustomDraw and then draw sockets on top of it
	
	// highlighting rectangle around is always drawn except for DRAW_SOCKETSONLY

	virtual int GetDrawingType ()
	{

		int nType = DRAW_AUTOMATICALLY;

		return nType;

	}


	// Custom Drawing
	// custom drawing function called when drawing type is different than DRAW_AUTOMATICALLY
	// it is not always in real pixels but scaled depending on where it is drawn
	// the scale could be from 1.0 to > 1.0
	// so you always multiply the position, sizes, font size, line width with the scale
	
	virtual void CustomDraw (HDC hDC, int nX,int nY, int nWidth, int nHeight, float scale, BOOL bIsHighlighted, UIParameters* pParameters)
	{
	}


	//************ Optional Functions *****************************************************************************************
	// those functions are not necessary for normal effect, they are mostly for special effects and objects


	// Called when FLAG_HELPER set. 
	// When UI data changed (user turned knob) this function will be called as soon as user finish channging the data
	// You will get the latest parameters and also which parameter changed
	// Normally for effects you don't have to do anything here because you will get the same parameters in the process function
	// It is only for helper objects that may not go to Process Data 
	BOOL UIParametersChanged (UIParameters* pParameters, int nParameter)
	{
		
		return FALSE;
	}

	// when button is pressed on UI, this function will be called with the parameter and sub button (for multi button line)
	BOOL UIButtonPushed (int nParam, int nSubButton, UIParameters* pParameters)
	{

		return TRUE;
	}


	// Called when FLAG_NEEDSIZEDATA set
	// Called before each calculation (Process_Data)
	// If your process depends on a position on a frame you may need the data to correctly display it because Process_Data receives only a preview crop
	// Most normal effects don't depend on the position in frame so you don't need the data
	// Example: drawing a circle at a certain position requires to know what is displayed in preview or the circle will be at the same size and position regardless of zoom
	
	// Note: Even if you need position but you don't want to mess with the crop data, just ignore it and pretend the Process_Data are always of full image (they are not). 
	// In worst case this affects only preview when using zoom. The full process image always sends the whole data

	// nOriginalW, nOriginalH - the size of the original - full image. If user sets Resize on input - this will be the resized image
	// nPreviewW, nPreviewH   - this is the currently processed preview width/height - it is the same that Process_Data will receive
	//                        - in full process the nPreviewW, nPreviewH is equal nOriginalW, nOriginalH
	// Crop X1,Y1,X2,Y2       - relative coordinates of preview crop rectangle in <0...1>, for full process they are 0,0,1,1 (full rectangle)	
	// dZoom                  - Zoom of the Preview, for full process the dZoom = 1.0
	void SetSizeData(int nOriginalW, int nOriginalH, int nPreviewW, int nPreviewH, double dCropX1, double dCropY1, double dCropX2, double dCropY2, double dZoom)
	{

		// so if you need the position and zoom, this is the place to get it.
		// Note: because of IBM wisdom the internal bitmaps are on PC always upside down, but the coordinates are not


	}


	// ***** Mouse handling on workplace *************************** 
	// only if FLAG_NEEDMOUSE is set
	//****************************************************************
	//this is for special objects that need to receive mouse, like a knob or slider on workplace
	// normally you use this for FLAG_BINDING objects

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonDown (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// return FALSE if not handled
		// return TRUE if handled
		return FALSE;
	}

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseMove (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
	

		return FALSE;
	}
	
	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonUp (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// Note: if we changed data and need to recalculate the flow we need to return TRUE

		// return FALSE if not handled
		// return TRUE if handled
		
		return TRUE;
	}


};

extern "C"
{
	// Plugin factory function
	__declspec(dllexport) IPlugin* Create_Plugin ()
	{
		//allocate a new object and return it
		return new Plugin1 ();
	}
	
	// Plugin cleanup function
	__declspec(dllexport) void Release_Plugin (IPlugin* p_plugin)
	{
		//we allocated in the factory with new, delete the passed object
		delete p_plugin;
	}
	
}


// this is the name that will appear in the object library
extern "C" __declspec(dllexport) char* GetPluginName()
{
	return "! AA median";	
}


// This MUST be unique string for each plugin so we can save the data

extern "C" __declspec(dllexport) char* GetPluginID()
{
	
	
	return "com.lumafilters.median";
	
}


// category of plugin, for now the EFFECT go to top library box, everything else goes to the middle library box
extern "C" __declspec(dllexport) int GetCategory()
{
		
	return CATEGORY_EFFECT;
	
}
